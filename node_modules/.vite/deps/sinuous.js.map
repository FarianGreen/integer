{
  "version": 3,
  "sources": ["../../sinuous/src/observable.js", "../../sinuous/src/h.js", "../../sinuous/src/htm.js", "../../sinuous/src/index.js"],
  "sourcesContent": ["const EMPTY_ARR = [];\nlet tracking;\nlet queue;\n\n/**\n * Returns true if there is an active observer.\n * @return {boolean}\n */\nexport function isListening() {\n  return !!tracking;\n}\n\n/**\n * Creates a root and executes the passed function that can contain computations.\n * The executed function receives an `unsubscribe` argument which can be called to\n * unsubscribe all inner computations.\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function root(fn) {\n  const prevTracking = tracking;\n  const rootUpdate = () => {};\n  tracking = rootUpdate;\n  resetUpdate(rootUpdate);\n  const result = fn(() => {\n    _unsubscribe(rootUpdate);\n    tracking = undefined;\n  });\n  tracking = prevTracking;\n  return result;\n}\n\n/**\n * Sample the current value of an observable but don't create a dependency on it.\n *\n * @example\n * computed(() => { if (foo()) bar(sample(bar) + 1); });\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function sample(fn) {\n  const prevTracking = tracking;\n  tracking = undefined;\n  const value = fn();\n  tracking = prevTracking;\n  return value;\n}\n\n/**\n * Creates a transaction in which an observable can be set multiple times\n * but only trigger a computation once.\n * @param  {Function} fn\n * @return {*}\n */\nexport function transaction(fn) {\n  let prevQueue = queue;\n  queue = [];\n  const result = fn();\n  let q = queue;\n  queue = prevQueue;\n  q.forEach((data) => {\n    if (data._pending !== EMPTY_ARR) {\n      const pending = data._pending;\n      data._pending = EMPTY_ARR;\n      data(pending);\n    }\n  });\n  return result;\n}\n\n/**\n * Creates a new observable, returns a function which can be used to get\n * the observable's value by calling the function without any arguments\n * and set the value by passing one argument of any type.\n *\n * @param  {*} value - Initial value.\n * @return {Function}\n */\nfunction observable(value) {\n  function data(nextValue) {\n    if (arguments.length === 0) {\n      if (tracking && !data._observers.has(tracking)) {\n        data._observers.add(tracking);\n        tracking._observables.push(data);\n      }\n      return value;\n    }\n\n    if (queue) {\n      if (data._pending === EMPTY_ARR) {\n        queue.push(data);\n      }\n      data._pending = nextValue;\n      return nextValue;\n    }\n\n    value = nextValue;\n\n    // Clear `tracking` otherwise a computed triggered by a set\n    // in another computed is seen as a child of that other computed.\n    const clearedUpdate = tracking;\n    tracking = undefined;\n\n    // Update can alter data._observers, make a copy before running.\n    data._runObservers = new Set(data._observers);\n    data._runObservers.forEach((observer) => (observer._fresh = false));\n    data._runObservers.forEach((observer) => {\n      if (!observer._fresh) observer();\n    });\n\n    tracking = clearedUpdate;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  // Used in sinuous/h/src/property.js\n  data.$o = 1;\n  data._observers = new Set();\n  // The 'not set' value must be unique, so `nullish` can be set in a transaction.\n  data._pending = EMPTY_ARR;\n\n  return data;\n}\n\n/**\n * @namespace\n * @borrows observable as o\n */\nexport { observable, observable as o };\n\n/**\n * Creates a new computation which runs when defined and automatically re-runs\n * when any of the used observable's values are set.\n *\n * @param {Function} observer\n * @param {*} value - Seed value.\n * @return {Function} Computation which can be used in other computations.\n */\nfunction computed(observer, value) {\n  observer._update = update;\n\n  // if (tracking == null) {\n  //   console.warn(\"computations created without a root or parent will never be disposed\");\n  // }\n\n  resetUpdate(update);\n  update();\n\n  function update() {\n    const prevTracking = tracking;\n    if (tracking) {\n      tracking._children.push(update);\n    }\n\n    _unsubscribe(update);\n    update._fresh = true;\n    tracking = update;\n    value = observer(value);\n\n    tracking = prevTracking;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  // Used in sinuous/h/src/property.js\n  data.$o = 1;\n\n  function data() {\n    if (update._fresh) {\n      if (tracking) {\n        // If being read from inside another computed, pass observables to it\n        update._observables.forEach((o) => o());\n      }\n    } else {\n      value = update();\n    }\n    return value;\n  }\n\n  return data;\n}\n\n/**\n * @namespace\n * @borrows computed as S\n */\nexport { computed, computed as S };\n\n/**\n * Run the given function just before the enclosing computation updates\n * or is disposed.\n * @param  {Function} fn\n * @return {Function}\n */\nexport function cleanup(fn) {\n  if (tracking) {\n    tracking._cleanups.push(fn);\n  }\n  return fn;\n}\n\n/**\n * Subscribe to updates of an observable.\n * @param  {Function} observer\n * @return {Function}\n */\nexport function subscribe(observer) {\n  computed(observer);\n  return () => _unsubscribe(observer._update);\n}\n\n/**\n * Statically declare a computation's dependencies.\n *\n * @param  {Function|Array}   obs\n * @param  {Function} fn - Callback function.\n * @param  {*} [seed] - Seed value.\n * @param  {boolean} [onchanges] - If true the initial run is skipped.\n * @return {Function} Computation which can be used in other computations.\n */\nexport function on(obs, fn, seed, onchanges) {\n  obs = [].concat(obs);\n  return computed((value) => {\n    obs.forEach((o) => o());\n\n    let result = value;\n    if (!onchanges) {\n      result = sample(() => fn(value));\n    }\n\n    onchanges = false;\n    return result;\n  }, seed);\n}\n\n/**\n * Unsubscribe from an observer.\n * @param  {Function} observer\n */\nexport function unsubscribe(observer) {\n  _unsubscribe(observer._update);\n}\n\nfunction _unsubscribe(update) {\n  update._children.forEach(_unsubscribe);\n  update._observables.forEach((o) => {\n    o._observers.delete(update);\n    if (o._runObservers) {\n      o._runObservers.delete(update);\n    }\n  });\n  update._cleanups.forEach((c) => c());\n  resetUpdate(update);\n}\n\nfunction resetUpdate(update) {\n  // Keep track of which observables trigger updates. Needed for unsubscribe.\n  update._observables = [];\n  update._children = [];\n  update._cleanups = [];\n}\n", "/* Adapted from Hyper DOM Expressions - The MIT License - Ryan Carniato */\n\n/**\n * Internal API.\n * Consumer must provide an observable at api.subscribe<T>(observer: () => T).\n *\n * @typedef {boolean} hSVG Determines if `h` will build HTML or SVG elements\n * @type {{\n * h:         import('./h.js').hTag\n * s:         hSVG\n * insert:    import('./insert.js').hInsert\n * property:  import('./property.js').hProperty\n * add:       import('./add.js').hAdd\n * rm:        import('./remove-nodes.js').hRemoveNodes\n * subscribe: (observer: () => *) => void\n * }}\n */\n// @ts-ignore Object is populated in index.js\nexport const api = {};\n\n/** @type {[]} Instead of `any[]` */\nconst EMPTY_ARR = [];\n\n/** @type {(value: *) => Text | Node | DocumentFragment} */\nconst castNode = (value) => {\n  if (typeof value === 'string') {\n    return document.createTextNode(value);\n  }\n  // Note that a DocumentFragment is an instance of Node\n  if (!(value instanceof Node)) {\n    // Passing an empty array creates a DocumentFragment\n    // Note this means api.add is not purely a subcall of api.h; it can nest\n    return api.h(EMPTY_ARR, value);\n  }\n  return value;\n};\n\n/**\n * @typedef {{ _startMark: Text }} Frag\n * @type {(value: Text | Node | DocumentFragment) => (Node | Frag)?}\n */\nconst frag = (value) => {\n  const { childNodes } = value;\n  if (!childNodes || value.nodeType !== 11) return;\n  if (childNodes.length < 2) return childNodes[0];\n  // For a fragment of 2 elements or more add a startMark. This is required for\n  // multiple nested conditional computeds that return fragments.\n\n  // It looks recursive here but the next call's fragOrNode is only Text('')\n  return {\n    _startMark: /** @type {Text} */ (api.add(value, '', childNodes[0])),\n  };\n};\n\n/**\n * Add a string or node before a reference node or at the end.\n * @typedef {Node | string | number} Value\n * @typedef {(parent: Node, value: Value | Value[], endMark: Node?) => Node | Frag} hAdd\n * @type {hAdd}\n */\nexport const add = (parent, value, endMark) => {\n  value = castNode(value);\n  const fragOrNode = frag(value) || value;\n\n  // If endMark is `null`, value will be added to the end of the list.\n  parent.insertBefore(value, endMark && endMark.parentNode && endMark);\n  return fragOrNode;\n};\n\n/**\n * @typedef {import('./add.js').Frag} Frag\n * @typedef {(el: Node, value: *, endMark: Node?, current: (Node | Frag)?,\n * startNode: Node?) => Node | Frag } hInsert\n * @type {hInsert}\n */\nexport const insert = (el, value, endMark, current, startNode) => {\n  // This is needed if the el is a DocumentFragment initially.\n  el = (endMark && endMark.parentNode) || el;\n\n  // Save startNode of current. In clear() endMark.previousSibling is not always\n  // accurate if content gets pulled before clearing.\n  startNode = startNode || (current instanceof Node && current);\n\n  // @ts-ignore Allow empty if statement\n  if (value === current);\n  else if (\n    (!current || typeof current === 'string') &&\n    // @ts-ignore Doesn't like `value += ''`\n    // eslint-disable-next-line no-implicit-coercion\n    (typeof value === 'string' || (typeof value === 'number' && (value += '')))\n  ) {\n    // Block optimized for string insertion.\n    // eslint-disable-next-line eqeqeq\n    if (current == null || !el.firstChild) {\n      if (endMark) {\n        api.add(el, value, endMark);\n      } else {\n        // Using textContent is a lot faster than append -> createTextNode.\n        el.textContent = /** @type {string} See `value += '' */ (value);\n      }\n    } else {\n      if (endMark) {\n        (endMark.previousSibling || el.lastChild).data = value;\n      } else {\n        el.firstChild.data = value;\n      }\n    }\n    current = value;\n  } else if (typeof value === 'function') {\n    api.subscribe(() => {\n      current = api.insert(\n        el,\n        value.call({ el, endMark }),\n        endMark,\n        current,\n        startNode\n      );\n    });\n  } else {\n    // Block for nodes, fragments, Arrays, non-stringables and node -> stringable.\n    if (endMark) {\n      // `current` can't be `0`, it's coerced to a string in insert.\n      if (current) {\n        if (!startNode) {\n          // Support fragments\n          startNode =\n            (current._startMark && current._startMark.nextSibling) ||\n            endMark.previousSibling;\n        }\n        api.rm(el, startNode, endMark);\n      }\n    } else {\n      el.textContent = '';\n    }\n    current = null;\n\n    if (value && value !== true) {\n      current = api.add(el, value, endMark);\n    }\n  }\n\n  return current;\n};\n\n/**\n * Proxy an event to hooked event handlers.\n * @this Node & { _listeners: { [name: string]: (ev: Event) => * } }\n * @type {(e: Event) => *}\n */\nfunction eventProxy(e) {\n  return this._listeners && this._listeners[e.type](e);\n}\n\n/**\n * @type {(el: Node, name: string, value: (ev: Event?) => *) => void}\n */\nconst handleEvent = (el, name, value) => {\n  name = name.slice(2).toLowerCase();\n\n  if (value) {\n    el.addEventListener(name, eventProxy);\n  } else {\n    el.removeEventListener(name, eventProxy);\n  }\n\n  (el._listeners || (el._listeners = {}))[name] = value;\n};\n\n/**\n * @typedef {(el: Node, value: *, name: string, isAttr: boolean?, isCss: boolean?) => void} hProperty\n * @type {hProperty}\n */\nexport const property = (el, value, name, isAttr, isCss) => {\n  // eslint-disable-next-line eqeqeq\n  if (value == null) return;\n  if (!name || (name === 'attrs' && (isAttr = true))) {\n    for (name in value) {\n      api.property(el, value[name], name, isAttr, isCss);\n    }\n  } else if (name[0] === 'o' && name[1] === 'n' && !value.$o) {\n    // Functions added as event handlers are not executed\n    // on render unless they have an observable indicator.\n    handleEvent(el, name, value);\n  } else if (typeof value === 'function') {\n    api.subscribe(() => {\n      api.property(el, value.call({ el, name }), name, isAttr, isCss);\n    });\n  } else if (isCss) {\n    el.style.setProperty(name, value);\n  } else if (\n    isAttr ||\n    name.slice(0, 5) === 'data-' ||\n    name.slice(0, 5) === 'aria-'\n  ) {\n    el.setAttribute(name, value);\n  } else if (name === 'style') {\n    if (typeof value === 'string') {\n      el.style.cssText = value;\n    } else {\n      api.property(el, value, null, isAttr, true);\n    }\n  } else {\n    if (name === 'class') name += 'Name';\n    el[name] = value;\n  }\n};\n\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endMark` (exclusive).\n * @typedef {(parent: Node, startNode: Node, endMark: Node) => void} hRemoveNodes\n * @type {hRemoveNodes}\n */\nexport const removeNodes = (parent, startNode, endMark) => {\n  while (startNode && startNode !== endMark) {\n    const n = startNode.nextSibling;\n    // Is needed in case the child was pulled out the parent before clearing.\n    if (parent === startNode.parentNode) {\n      parent.removeChild(startNode);\n    }\n    startNode = n;\n  }\n};\n\n/**\n * Sinuous `h` tag aka hyperscript.\n * @typedef {HTMLElement | SVGElement | DocumentFragment} DOM\n * @typedef {(tag: string? | [], props: object?, ...children: Node | *) => DOM} hTag\n * @type {hTag}\n */\n\nexport const h = (...args) => {\n  let el;\n  const item = (/** @type {*} */ arg) => {\n    // @ts-ignore Allow empty if\n    // eslint-disable-next-line eqeqeq\n    if (arg == null);\n    else if (typeof arg === 'string') {\n      if (el) {\n        api.add(el, arg);\n      } else {\n        el = api.s\n          ? document.createElementNS('http://www.w3.org/2000/svg', arg)\n          : document.createElement(arg);\n      }\n    } else if (Array.isArray(arg)) {\n      // Support Fragments\n      if (!el) el = document.createDocumentFragment();\n      arg.forEach(item);\n    } else if (arg instanceof Node) {\n      if (el) {\n        api.add(el, arg);\n      } else {\n        // Support updates\n        el = arg;\n      }\n    } else if (typeof arg === 'object') {\n      // @ts-ignore 0 | 1 is a boolean but can't type cast; they don't overlap\n      api.property(el, arg, null, api.s);\n    } else if (typeof arg === 'function') {\n      if (el) {\n        // See note in add.js#frag() - This is a Text('') node\n        const endMark = /** @type {Text} */ (api.add(el, ''));\n        api.insert(el, arg, endMark);\n      } else {\n        // Support Components\n        el = arg.apply(null, args.splice(1));\n      }\n    } else {\n      // eslint-disable-next-line no-implicit-coercion,prefer-template\n      api.add(el, '' + arg);\n    }\n  };\n  args.forEach(item);\n  return el;\n};\n\n\napi.h = h;\napi.insert = insert;\napi.property = property;\napi.add = add;\napi.rm = removeNodes;\n", "/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const MINI = false;\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst TAG_SET = 1;\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst PROPS_ASSIGN = 3;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n//  treeify(\n//    build'<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//    [X, Y, Z]\n//  )\n// returns:\n//  {\n//    tag: 'div',\n//    props: [ { href: [\"1\", X] },  Y ],\n//    children: [ { tag: Z, props: [], children: [] } ]\n//  }\nexport const treeify = (built, fields) => {\n  const _treeify = built => {\n    let tag = '';\n    let currentProps = null;\n    const props = [];\n    const children = [];\n\n    for (let i = 1; i < built.length; i++) {\n      const field = built[i++];\n      const value = typeof field === 'number' ? fields[field - 1] : field;\n\n      if (built[i] === TAG_SET) {\n        tag = value;\n      }\n      else if (built[i] === PROPS_ASSIGN) {\n        props.push(value);\n        currentProps = null;\n      }\n      else if (built[i] === PROP_SET) {\n        if (!currentProps) {\n          currentProps = Object.create(null);\n          props.push(currentProps);\n        }\n        currentProps[built[++i]] = [value];\n      }\n      else if (built[i] === PROP_APPEND) {\n        currentProps[built[++i]].push(value);\n      }\n      else if (built[i] === CHILD_RECURSE) {\n        children.push(_treeify(value));\n      }\n      else if (built[i] === CHILD_APPEND) {\n        children.push(value);\n      }\n    }\n\n    return { tag, props, children };\n  };\n  const { children } = _treeify(built);\n  return children.length > 1 ? children : children[0];\n};\n\n\nexport const evaluate = (h, built, fields, args) => {\n  let propBody = {};\n  for (let i = 1; i < built.length; i++) {\n    const field = built[i];\n    const value = typeof field === 'number' ? fields[field] : field;\n    const type = built[++i];\n\n    if (type === TAG_SET) {\n      args[0] = value;\n    }\n    else if (type === PROPS_ASSIGN) {\n      args[1] = Object.assign(args[1] || {}, value);\n    }\n    else if (type === PROP_SET) {\n      (args[1] = args[1] || {})[built[++i]] = value;\n    }\n    else if (type === PROP_APPEND) {\n      let key = built[++i];\n      let prev = (args[1] = args[1] || {})[key];\n      let parts = propBody[key];\n\n      if (!parts && (typeof value === 'function' || typeof prev === 'function')) {\n        parts = (prev && [prev]) || [];\n\n        args[1][key] = function() {\n          let prop = '';\n          for (var j = 0; j < parts.length; j++) {\n            prop += typeof parts[j] === 'function' ? parts[j].call(this) : parts[j];\n          }\n          return prop;\n        };\n      }\n\n      if (parts) {\n        parts.push(value);\n      } else {\n        args[1][key] += (value + '');\n      }\n    }\n    else if (type) {\n      // code === CHILD_RECURSE\n      const result = () => h.apply(null, evaluate(h, value, fields, ['', null]));\n\n      // if it's a component we pass the children with closure so the\n      // component is executed before the children of that component.\n      args.push(typeof args[0] === 'function' ? result : result());\n    }\n    else {\n      // code === CHILD_APPEND\n      args.push(value);\n    }\n  }\n\n  return args;\n};\n\nexport const build = function(statics) {\n  const fields = arguments;\n  const h = this;\n\n  let mode = MODE_TEXT;\n  let buffer = '';\n  let quote = '';\n  let current = [0];\n  let char, propName;\n\n  const commit = field => {\n    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n      if (MINI) {\n        current.push(field ? fields[field] : buffer);\n      }\n      else {\n        current.push(field || buffer, CHILD_APPEND);\n      }\n    }\n    else if (mode === MODE_TAGNAME && (field || buffer)) {\n      if (MINI) {\n        current[1] = field ? fields[field] : buffer;\n      }\n      else {\n        current.push(field || buffer, TAG_SET);\n      }\n      mode = MODE_WHITESPACE;\n    }\n    else if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n      if (MINI) {\n        current[2] = Object.assign(current[2] || {}, fields[field]);\n      }\n      else {\n        current.push(field, PROPS_ASSIGN);\n      }\n    }\n    else if (mode === MODE_WHITESPACE && buffer && !field) {\n      if (MINI) {\n        (current[2] = current[2] || {})[buffer] = true;\n      }\n      else {\n        current.push(true, PROP_SET, buffer);\n      }\n    }\n    else if (mode >= MODE_PROP_SET) {\n      if (MINI) {\n        if (mode === MODE_PROP_SET) {\n          (current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n          mode = MODE_PROP_APPEND;\n        }\n        else if (field || buffer) {\n          current[2][propName] += field ? buffer + fields[field] : buffer;\n        }\n      }\n      else {\n        if (buffer || (!field && mode === MODE_PROP_SET)) {\n          current.push(buffer, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n        if (field) {\n          current.push(field, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n      }\n    }\n\n    buffer = '';\n  };\n\n  for (let i=0; i<statics.length; i++) {\n    if (i) {\n      if (mode === MODE_TEXT) {\n        commit();\n      }\n      commit(i);\n    }\n\n    for (let j=0; j<statics[i].length;j++) {\n      char = statics[i][j];\n\n      if (mode === MODE_TEXT) {\n        if (char === '<') {\n          // commit buffer\n          commit();\n          if (MINI) {\n            current = [current, '', null];\n          }\n          else {\n            current = [current];\n          }\n          mode = MODE_TAGNAME;\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (mode === MODE_COMMENT) {\n        // Ignore everything until the last three characters are '-', '-' and '>'\n        if (buffer === '--' && char === '>') {\n          mode = MODE_TEXT;\n          buffer = '';\n        }\n        else {\n          buffer = char + buffer[0];\n        }\n      }\n      else if (quote) {\n        if (char === quote) {\n          quote = '';\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (char === '\"' || char === \"'\") {\n        quote = char;\n      }\n      else if (char === '>') {\n        commit();\n        mode = MODE_TEXT;\n      }\n      else if (!mode) {\n        // Ignore everything until the tag ends\n      }\n      else if (char === '=') {\n        mode = MODE_PROP_SET;\n        propName = buffer;\n        buffer = '';\n      }\n      else if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n        commit();\n        if (mode === MODE_TAGNAME) {\n          current = current[0];\n        }\n        mode = current;\n        if (MINI) {\n          (current = current[0]).push(h.apply(null, mode.slice(1)));\n        }\n        else {\n          (current = current[0]).push(mode, CHILD_RECURSE);\n        }\n        mode = MODE_SLASH;\n      }\n      else if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n        // <a disabled>\n        commit();\n        mode = MODE_WHITESPACE;\n      }\n      else {\n        buffer += char;\n      }\n\n      if (mode === MODE_TAGNAME && buffer === '!--') {\n        mode = MODE_COMMENT;\n        current = current[0];\n      }\n    }\n  }\n  commit();\n\n  if (MINI) {\n    return current.length > 2 ? current.slice(1) : current[1];\n  }\n  return current;\n};\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n  let tmp = CACHES.get(this);\n  if (!tmp) {\n    tmp = new Map();\n    CACHES.set(this, tmp);\n  }\n  tmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n  return tmp.length > 1 ? tmp : tmp[0];\n};\n\nconst custom = function() {\n  const result = (MINI ? build : regular).apply(this, arguments);\n  if (result) {\n    return Array.isArray(result)\n      ? this(result)\n      : typeof result === 'object'\n      ? result\n      : this([result]);\n  }\n};\n\nconst wrapper = function() {\n  const h = custom.bind(this);\n  return (this.wrap || h).apply(h, arguments);\n};\n\nexport default wrapper;\n", "/*\n * Sinuous by Wesley Luyten (@luwes).\n * Really ties all the packages together.\n */\nimport {\n  o,\n  observable,\n  computed,\n  subscribe,\n  cleanup,\n  root,\n  sample,\n} from './observable.js';\nimport { api } from './h.js';\nimport htm from './htm.js';\n\n// Minified this is actually smaller than Object.assign(api, { ... })\napi.subscribe = subscribe;\napi.cleanup = cleanup;\napi.root = root;\napi.sample = sample;\n\napi.hs = (...args) => {\n  const prevIsSvg = api.s;\n  api.s = true;\n  const el = h(...args);\n  api.s = prevIsSvg;\n  return el;\n};\n\n// Makes it possible to intercept `h` calls and customize.\nexport const h = (...args) => api.h.apply(api.h, args);\n\n// Makes it possible to intercept `hs` calls and customize.\nexport const hs = (...args) => api.hs.apply(api.hs, args);\n\n// `export const html = htm.bind(h)` is not tree-shakeable!\nexport const html = (...args) => htm.apply(h, args);\n\n// `export const svg = htm.bind(hs)` is not tree-shakeable!\nexport const svg = (...args) => htm.apply(hs, args);\n\nexport { api, o, observable, computed };\n"],
  "mappings": "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",
  "names": ["EMPTY_ARR", "h", "h"]
}
