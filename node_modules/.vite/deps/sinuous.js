// node_modules/sinuous/src/observable.js
var EMPTY_ARR = [];
var tracking;
var queue;
function root(fn) {
  const prevTracking = tracking;
  const rootUpdate = () => {
  };
  tracking = rootUpdate;
  resetUpdate(rootUpdate);
  const result = fn(() => {
    _unsubscribe(rootUpdate);
    tracking = void 0;
  });
  tracking = prevTracking;
  return result;
}
function sample(fn) {
  const prevTracking = tracking;
  tracking = void 0;
  const value = fn();
  tracking = prevTracking;
  return value;
}
function observable(value) {
  function data(nextValue) {
    if (arguments.length === 0) {
      if (tracking && !data._observers.has(tracking)) {
        data._observers.add(tracking);
        tracking._observables.push(data);
      }
      return value;
    }
    if (queue) {
      if (data._pending === EMPTY_ARR) {
        queue.push(data);
      }
      data._pending = nextValue;
      return nextValue;
    }
    value = nextValue;
    const clearedUpdate = tracking;
    tracking = void 0;
    data._runObservers = new Set(data._observers);
    data._runObservers.forEach((observer) => observer._fresh = false);
    data._runObservers.forEach((observer) => {
      if (!observer._fresh) observer();
    });
    tracking = clearedUpdate;
    return value;
  }
  data.$o = 1;
  data._observers = /* @__PURE__ */ new Set();
  data._pending = EMPTY_ARR;
  return data;
}
function computed(observer, value) {
  observer._update = update;
  resetUpdate(update);
  update();
  function update() {
    const prevTracking = tracking;
    if (tracking) {
      tracking._children.push(update);
    }
    _unsubscribe(update);
    update._fresh = true;
    tracking = update;
    value = observer(value);
    tracking = prevTracking;
    return value;
  }
  data.$o = 1;
  function data() {
    if (update._fresh) {
      if (tracking) {
        update._observables.forEach((o) => o());
      }
    } else {
      value = update();
    }
    return value;
  }
  return data;
}
function cleanup(fn) {
  if (tracking) {
    tracking._cleanups.push(fn);
  }
  return fn;
}
function subscribe(observer) {
  computed(observer);
  return () => _unsubscribe(observer._update);
}
function _unsubscribe(update) {
  update._children.forEach(_unsubscribe);
  update._observables.forEach((o) => {
    o._observers.delete(update);
    if (o._runObservers) {
      o._runObservers.delete(update);
    }
  });
  update._cleanups.forEach((c) => c());
  resetUpdate(update);
}
function resetUpdate(update) {
  update._observables = [];
  update._children = [];
  update._cleanups = [];
}

// node_modules/sinuous/src/h.js
var api = {};
var EMPTY_ARR2 = [];
var castNode = (value) => {
  if (typeof value === "string") {
    return document.createTextNode(value);
  }
  if (!(value instanceof Node)) {
    return api.h(EMPTY_ARR2, value);
  }
  return value;
};
var frag = (value) => {
  const { childNodes } = value;
  if (!childNodes || value.nodeType !== 11) return;
  if (childNodes.length < 2) return childNodes[0];
  return {
    _startMark: (
      /** @type {Text} */
      api.add(value, "", childNodes[0])
    )
  };
};
var add = (parent, value, endMark) => {
  value = castNode(value);
  const fragOrNode = frag(value) || value;
  parent.insertBefore(value, endMark && endMark.parentNode && endMark);
  return fragOrNode;
};
var insert = (el, value, endMark, current, startNode) => {
  el = endMark && endMark.parentNode || el;
  startNode = startNode || current instanceof Node && current;
  if (value === current) ;
  else if ((!current || typeof current === "string") && // @ts-ignore Doesn't like `value += ''`
  // eslint-disable-next-line no-implicit-coercion
  (typeof value === "string" || typeof value === "number" && (value += ""))) {
    if (current == null || !el.firstChild) {
      if (endMark) {
        api.add(el, value, endMark);
      } else {
        el.textContent = /** @type {string} See `value += '' */
        value;
      }
    } else {
      if (endMark) {
        (endMark.previousSibling || el.lastChild).data = value;
      } else {
        el.firstChild.data = value;
      }
    }
    current = value;
  } else if (typeof value === "function") {
    api.subscribe(() => {
      current = api.insert(
        el,
        value.call({ el, endMark }),
        endMark,
        current,
        startNode
      );
    });
  } else {
    if (endMark) {
      if (current) {
        if (!startNode) {
          startNode = current._startMark && current._startMark.nextSibling || endMark.previousSibling;
        }
        api.rm(el, startNode, endMark);
      }
    } else {
      el.textContent = "";
    }
    current = null;
    if (value && value !== true) {
      current = api.add(el, value, endMark);
    }
  }
  return current;
};
function eventProxy(e) {
  return this._listeners && this._listeners[e.type](e);
}
var handleEvent = (el, name, value) => {
  name = name.slice(2).toLowerCase();
  if (value) {
    el.addEventListener(name, eventProxy);
  } else {
    el.removeEventListener(name, eventProxy);
  }
  (el._listeners || (el._listeners = {}))[name] = value;
};
var property = (el, value, name, isAttr, isCss) => {
  if (value == null) return;
  if (!name || name === "attrs" && (isAttr = true)) {
    for (name in value) {
      api.property(el, value[name], name, isAttr, isCss);
    }
  } else if (name[0] === "o" && name[1] === "n" && !value.$o) {
    handleEvent(el, name, value);
  } else if (typeof value === "function") {
    api.subscribe(() => {
      api.property(el, value.call({ el, name }), name, isAttr, isCss);
    });
  } else if (isCss) {
    el.style.setProperty(name, value);
  } else if (isAttr || name.slice(0, 5) === "data-" || name.slice(0, 5) === "aria-") {
    el.setAttribute(name, value);
  } else if (name === "style") {
    if (typeof value === "string") {
      el.style.cssText = value;
    } else {
      api.property(el, value, null, isAttr, true);
    }
  } else {
    if (name === "class") name += "Name";
    el[name] = value;
  }
};
var removeNodes = (parent, startNode, endMark) => {
  while (startNode && startNode !== endMark) {
    const n = startNode.nextSibling;
    if (parent === startNode.parentNode) {
      parent.removeChild(startNode);
    }
    startNode = n;
  }
};
var h = (...args) => {
  let el;
  const item = (arg) => {
    if (arg == null) ;
    else if (typeof arg === "string") {
      if (el) {
        api.add(el, arg);
      } else {
        el = api.s ? document.createElementNS("http://www.w3.org/2000/svg", arg) : document.createElement(arg);
      }
    } else if (Array.isArray(arg)) {
      if (!el) el = document.createDocumentFragment();
      arg.forEach(item);
    } else if (arg instanceof Node) {
      if (el) {
        api.add(el, arg);
      } else {
        el = arg;
      }
    } else if (typeof arg === "object") {
      api.property(el, arg, null, api.s);
    } else if (typeof arg === "function") {
      if (el) {
        const endMark = (
          /** @type {Text} */
          api.add(el, "")
        );
        api.insert(el, arg, endMark);
      } else {
        el = arg.apply(null, args.splice(1));
      }
    } else {
      api.add(el, "" + arg);
    }
  };
  args.forEach(item);
  return el;
};
api.h = h;
api.insert = insert;
api.property = property;
api.add = add;
api.rm = removeNodes;

// node_modules/sinuous/src/htm.js
var MINI = false;
var MODE_SLASH = 0;
var MODE_TEXT = 1;
var MODE_WHITESPACE = 2;
var MODE_TAGNAME = 3;
var MODE_COMMENT = 4;
var MODE_PROP_SET = 5;
var MODE_PROP_APPEND = 6;
var TAG_SET = 1;
var CHILD_APPEND = 0;
var CHILD_RECURSE = 2;
var PROPS_ASSIGN = 3;
var PROP_SET = MODE_PROP_SET;
var PROP_APPEND = MODE_PROP_APPEND;
var evaluate = (h3, built, fields, args) => {
  let propBody = {};
  for (let i = 1; i < built.length; i++) {
    const field = built[i];
    const value = typeof field === "number" ? fields[field] : field;
    const type = built[++i];
    if (type === TAG_SET) {
      args[0] = value;
    } else if (type === PROPS_ASSIGN) {
      args[1] = Object.assign(args[1] || {}, value);
    } else if (type === PROP_SET) {
      (args[1] = args[1] || {})[built[++i]] = value;
    } else if (type === PROP_APPEND) {
      let key = built[++i];
      let prev = (args[1] = args[1] || {})[key];
      let parts = propBody[key];
      if (!parts && (typeof value === "function" || typeof prev === "function")) {
        parts = prev && [prev] || [];
        args[1][key] = function() {
          let prop = "";
          for (var j = 0; j < parts.length; j++) {
            prop += typeof parts[j] === "function" ? parts[j].call(this) : parts[j];
          }
          return prop;
        };
      }
      if (parts) {
        parts.push(value);
      } else {
        args[1][key] += value + "";
      }
    } else if (type) {
      const result = () => h3.apply(null, evaluate(h3, value, fields, ["", null]));
      args.push(typeof args[0] === "function" ? result : result());
    } else {
      args.push(value);
    }
  }
  return args;
};
var build = function(statics) {
  const fields = arguments;
  const h3 = this;
  let mode = MODE_TEXT;
  let buffer = "";
  let quote = "";
  let current = [0];
  let char, propName;
  const commit = (field) => {
    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\s*\n\s*|\s*\n\s*$/g, "")))) {
      if (MINI) {
        current.push(field ? fields[field] : buffer);
      } else {
        current.push(field || buffer, CHILD_APPEND);
      }
    } else if (mode === MODE_TAGNAME && (field || buffer)) {
      if (MINI) {
        current[1] = field ? fields[field] : buffer;
      } else {
        current.push(field || buffer, TAG_SET);
      }
      mode = MODE_WHITESPACE;
    } else if (mode === MODE_WHITESPACE && buffer === "..." && field) {
      if (MINI) {
        current[2] = Object.assign(current[2] || {}, fields[field]);
      } else {
        current.push(field, PROPS_ASSIGN);
      }
    } else if (mode === MODE_WHITESPACE && buffer && !field) {
      if (MINI) {
        (current[2] = current[2] || {})[buffer] = true;
      } else {
        current.push(true, PROP_SET, buffer);
      }
    } else if (mode >= MODE_PROP_SET) {
      if (MINI) {
        if (mode === MODE_PROP_SET) {
          (current[2] = current[2] || {})[propName] = field ? buffer ? buffer + fields[field] : fields[field] : buffer;
          mode = MODE_PROP_APPEND;
        } else if (field || buffer) {
          current[2][propName] += field ? buffer + fields[field] : buffer;
        }
      } else {
        if (buffer || !field && mode === MODE_PROP_SET) {
          current.push(buffer, mode, propName);
          mode = MODE_PROP_APPEND;
        }
        if (field) {
          current.push(field, mode, propName);
          mode = MODE_PROP_APPEND;
        }
      }
    }
    buffer = "";
  };
  for (let i = 0; i < statics.length; i++) {
    if (i) {
      if (mode === MODE_TEXT) {
        commit();
      }
      commit(i);
    }
    for (let j = 0; j < statics[i].length; j++) {
      char = statics[i][j];
      if (mode === MODE_TEXT) {
        if (char === "<") {
          commit();
          if (MINI) {
            current = [current, "", null];
          } else {
            current = [current];
          }
          mode = MODE_TAGNAME;
        } else {
          buffer += char;
        }
      } else if (mode === MODE_COMMENT) {
        if (buffer === "--" && char === ">") {
          mode = MODE_TEXT;
          buffer = "";
        } else {
          buffer = char + buffer[0];
        }
      } else if (quote) {
        if (char === quote) {
          quote = "";
        } else {
          buffer += char;
        }
      } else if (char === '"' || char === "'") {
        quote = char;
      } else if (char === ">") {
        commit();
        mode = MODE_TEXT;
      } else if (!mode) {
      } else if (char === "=") {
        mode = MODE_PROP_SET;
        propName = buffer;
        buffer = "";
      } else if (char === "/" && (mode < MODE_PROP_SET || statics[i][j + 1] === ">")) {
        commit();
        if (mode === MODE_TAGNAME) {
          current = current[0];
        }
        mode = current;
        if (MINI) {
          (current = current[0]).push(h3.apply(null, mode.slice(1)));
        } else {
          (current = current[0]).push(mode, CHILD_RECURSE);
        }
        mode = MODE_SLASH;
      } else if (char === " " || char === "	" || char === "\n" || char === "\r") {
        commit();
        mode = MODE_WHITESPACE;
      } else {
        buffer += char;
      }
      if (mode === MODE_TAGNAME && buffer === "!--") {
        mode = MODE_COMMENT;
        current = current[0];
      }
    }
  }
  commit();
  if (MINI) {
    return current.length > 2 ? current.slice(1) : current[1];
  }
  return current;
};
var CACHES = /* @__PURE__ */ new Map();
var regular = function(statics) {
  let tmp = CACHES.get(this);
  if (!tmp) {
    tmp = /* @__PURE__ */ new Map();
    CACHES.set(this, tmp);
  }
  tmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);
  return tmp.length > 1 ? tmp : tmp[0];
};
var custom = function() {
  const result = (MINI ? build : regular).apply(this, arguments);
  if (result) {
    return Array.isArray(result) ? this(result) : typeof result === "object" ? result : this([result]);
  }
};
var wrapper = function() {
  const h3 = custom.bind(this);
  return (this.wrap || h3).apply(h3, arguments);
};
var htm_default = wrapper;

// node_modules/sinuous/src/index.js
api.subscribe = subscribe;
api.cleanup = cleanup;
api.root = root;
api.sample = sample;
api.hs = (...args) => {
  const prevIsSvg = api.s;
  api.s = true;
  const el = h2(...args);
  api.s = prevIsSvg;
  return el;
};
var h2 = (...args) => api.h.apply(api.h, args);
var hs = (...args) => api.hs.apply(api.hs, args);
var html = (...args) => htm_default.apply(h2, args);
var svg = (...args) => htm_default.apply(hs, args);
export {
  api,
  computed,
  h2 as h,
  hs,
  html,
  observable as o,
  observable,
  svg
};
//# sourceMappingURL=sinuous.js.map
